;
; Closures are functions that are not immediately user-defined, not with the 'func'
; keyword at least. Closures are more powerful lambdas, for example they can reference 
; variables in the scope they are created in, even though when they'll be executed the
; scope will no longer exist. To do just that a closure object must be created, that
; stores a function pointer to the lambda and the values taken from the current scope.
; These values are called closure arguments.
; 
; When calling a closure, the arguments are stored on the stack, as usual, and the 
; closure object must be stored in $rax, then a 'call [rax]' instruction can be
; performed. The function called can choose to store the closure object on the stack.
;

;
; Native operation closures are closures that run a single operation (like + or -)
; on one or two operands.
; -- They are generated by the AHK compiler at compile time
;
 
;
; Conversion functions are used to cast a closure from a (function) type to another,
; for example (int):float can be converted to (float):float by casting the first (and
; only) argument from an int to a float. A conversion function takes a single argument
; and casts it to another type.
; Conversion functions do not take their arguments on the stack but rather in $rax,
; they also return in $rax. They do not have to keep other registers unaffected.
; The function_noop function is technically a conversion function that converts from
; a type to itself.
; -- They are generated by the AHK compiler at compile time
;



; closure memory block:
; -----------------------------
;         u8 memory_block_size
; ptr --> u8 *closure_func
;  +8     u8 arguments_stack_space (in bytes)
;      () additional arguments for specific closures
; -----------------------------


; constant lambda closure memory block:
; -----------------------------
;  ...
;  +16    u8 return_value
; -----------------------------


; composition closure memory block:
; -----------------------------
;  ...
;  +16    u8 *first_func
;  +24    u8 *second_func
; -----------------------------


; 2 operands operation composition closure memory block:
; -----------------------------
;  ...
;  +16    u8 *first_closure
;  +24    u8 *second_closure
;  +32    u8 *operation_func - function pointer, NOT a closure
; -----------------------------


; 1 operand operation composition closure memory block:
; -----------------------------
;  ...
;  +16    u8 *first_closure
;  +24    u8 *operation_func - function pointer, NOT a closure
; -----------------------------


; casted closure memory block:
; -----------------------------
;  ...
;  +16    u8 *original_closure
;  +24    u8 *return type conversion function
;  +32    u8 *conversion function for arg 1
;  +40    u8 *conversion function for arg 2
;  ...
;  +x     u8 *conversion function for arg n
; -----------------------------

segment .data

global closure_run_constant
global closure_run_composed
global closure_run_operation_1
global closure_run_operation_2
global closure_run_casted
global function_noop

; extern labels required by native operation closures
extern global_fsignbit
extern mem_alloc_block
extern error_throw
extern global_floatst

&native_operation_closures_globals
&native_conversion_closures_globals


segment .text


function_noop:
  ret


closure_run_constant:
  mov rbx,[rax+8]       ; arguments count
  mov rcx,rsp
  lea rsp,[rsp+8*rbx+8] ; "pop" the arguments space and this method's return address
  
  mov rax,[rax+16]      ; return value
  
  jmp [rcx]             ; "return", this method's return address is no longer
                        ; "in" the stack but it still exists where it was
                        ;  originally (its address is lower than rsp)
  

; when called, $rax must be the pointer to the closure
; (see the composition closure memory block description)
closure_run_composed:
  push rbp
  mov rbp,rsp
  
  ; we cannot call the closure's functions directly
  ; because the return address pushed by 'call'
  ; would mess up the stack, instead we copy the
  ; arguments and take care of removing the original
  ; arguments from the stack after
  
  mov rcx,[rax+8] ; arguments count
  mov rdx,rcx
  shl rdx,3       ; arguments space
  
  push rdx ; store the arguments space
  push rax ; store the closure
  
  sub rsp,rdx ; arguments space
  
  lea rsi,[rbp+rdx+8] ; begining of arguments
  mov rdi,rsp         ; address of the copy
  cld
  rep movsq           ; copy arguments (rcx is the argument count)
  
  mov rax,[rax+16] ; retrieve the first closure
  call [rax]       ; make the first call
  push rax         ; pass the result of the first call to the second
  mov rax,[rsp+8]
  mov rax,[rax+24] ; retrieve the second closure
  call [rax]       ; make the second call
  
  mov rdx,[rsp+8] ; retrieve the arguments space
  
  mov rsp,rbp ; end the stack frame
  pop rbp
  
  ; the next instructions are used instead of 'ret' because
  ; we must pop the arguments from the stack
  mov rcx,rsp
  add rsp,rdx ; "pop" the arguments space
  add rsp,8   ; "pop" this method's return address
  
  jmp [rcx]   ; "return", this method's return address is no longer
              ; "in" the stack but it still exists where it was
              ;  originally (its address is lower than rsp)
  
  
; run an operation closure with two closure operands
closure_run_operation_2:
  push rbp
  mov rbp,rsp
  
  mov rcx,[rax+8]
  mov rdx,rcx
  shl rdx,3
  
  push rdx
  push rax
  
  ; copy args
  sub rsp,rdx
  lea rsi,[rbp+rdx+8]
  mov rdi,rsp
  cld
  rep movsq
  
  ; call the first closure
  mov rax,[rax+16]
  call [rax]
  push rax
  
  ; copy args
  mov rdx,[rsp+16]
  mov rcx,rdx
  sub rsp,rcx
  shr rcx,3
  lea rsi,[rbp+rdx+8]
  mov rdi,rsp
  cld
  rep movsq
  
  ; call the second closure
  mov rax,[rsp+rdx+8]
  mov rax,[rax+24]
  call [rax]
  push rax
  
  ; call the operation
  mov rax,[rsp+16]
  call [rax+32]
  
  mov rdx,[rsp+8]
  
  mov rsp,rbp
  pop rbp
  
  mov rcx,rsp
  add rsp,rdx
  add rsp,8
  
  jmp [rcx]
  

  
; run an operation closure with a single operand
closure_run_operation_1:
  push rbp
  mov rbp,rsp
  
  mov rcx,[rax+8]
  mov rdx,rcx
  shl rdx,3
  
  push rdx
  push rax
  
  ; copy args
  sub rsp,rdx
  lea rsi,[rbp+rdx+8]
  mov rdi,rsp
  cld
  rep movsq
  
  ; call the closure
  mov rax,[rax+16]
  call [rax]
  push rax
  ; call the operation
  mov rax,[rsp+8]
  call [rax+24]
  
  mov rdx,[rsp+8]
  
  mov rsp,rbp
  pop rbp
  
  mov rcx,rsp
  add rsp,rdx
  add rsp,8
  
  jmp [rcx]
  

closure_run_casted:
  push rbp
  mov rbp,rsp
  sub rsp,16
  
  mov [rbp-8],rax  ; store the closure pointer
  mov rcx,[rax+8]  ; retrieve the arguments stack space
  shr rcx,3        ; divide by 8 to get the number of arguments
  mov [rbp-16],rcx ; store the number of remaining conversions
  
.conversions_loop:
  mov rcx,[rbp-16]
  test rcx,rcx
  jz .done_conversions
  dec rcx
  mov [rbp-16],rcx
  mov rbx,[rbp-8]        ; retrieve the closure pointer
  mov rax,[rbp+16+8*rcx] ; retrieve the argument
  call [rbx+32+8*rcx]    ; call the conversion function
  mov rbx,[rbp-8]
  mov rcx,[rbp-16]
  mov [rbp+16+8*rcx],rax ; store the converted argument
  jmp .conversions_loop
  
.done_conversions:
  mov rax,[rbp-8]  ; retrieve the closure pointer
  
  ; copy the arguments
  mov rcx,[rax+8]
  test rcx,rcx
  jz .copied_arguments
  sub rsp,rcx      ; make space for the arguments
  mov rdi,rsp
  lea rsi,[rbp+16]
  cld
  rep movsb
  
.copied_arguments:
  mov rax,[rax+16] ; retrieve the original closure
  call [rax]       ; call the original closure
  ; at that point $rax contains the non-casted return value
  mov rbx,[rbp-8]  ; retrieve the closure pointer
  call [rbx+24]    ; call the return type conversion function (not a closure)
  ; at that point $rax contains the final return value
  
  mov rbx,[rbp-8]  ; retrieve the closure pointer
  
  mov rsp,rbp
  pop rbp
  
  ; the next instructions are used instead of 'ret' because
  ; we must pop the arguments from the stack
  mov rcx,rsp
  add rsp,[rbx+8] ; "pop" the arguments space
  add rsp,8       ; "pop" this method's return address
  jmp [rcx]       ; "return", this method's return address is no longer
                  ; "in" the stack but it still exists where it was
                  ;  originally (its address is lower than rsp)
  
  
; ------------------------------------ Operation closures ------------------------------------
&native_operation_closures

; ----------------------------------- Conversions closures -----------------------------------
&native_conversion_closures
  